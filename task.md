Практическая работа № 13
Разработка микросервисного приложения
с использованием сетецентрической архитектуры
Цель работы:
Освоить принципы проектирования и реализации программных систем на основе
сетецентрической архитектуры, в которой компоненты взаимодействуют исключительно
через сеть, а не через локальные вызовы. Закрепить навыки разработки микросервисов,
контейнеризации и сетевого взаимодействия.
Основные понятия
Сетецентричная архитектура (Network-Centric Architecture) — подход, при котором сеть
рассматривается как основная среда взаимодействия компонентов системы. Вычисления,
данные и управление распределены, а связь между модулями осуществляется посредством
сетевых протоколов.
Микросервис — независимо развертываемый, слабосвязанный компонент системы,
выполняющий одну бизнес-функцию и взаимодействующий с другими через API.
Loose coupling — слабая связанность: изменение одного сервиса не требует изменения
других.
Statelessness — сервис не хранит состояние между запросами; всё необходимое передаётся в
запросе.
Задачи:
1. Изучить основные концепции:
o Сетецентричная архитектура (в отличие от традиционной монолитной).
o Микросервисы как пример сетецентричного подхода.
o Принципы loose coupling, service discovery, statelessness.
2. Спроектировать архитектуру приложения:
o Приложение должно состоять как минимум из 3 микросервисов (например:
User Service, Order Service, Notification Service).
o Все взаимодействия между сервисами реализуются только через сеть
(HTTP/gRPC).
o Каждый сервис — автономное приложение с собственной БД.
3. Реализовать сервисы:
o Использовать любой подходящий стек (например: Python + Flask/FastAPI,
Node.js + Express, Java + Spring Boot).
o Реализовать базовые CRUD-операции и взаимодействие между сервисами
(например: при создании заказа вызывать User Service для проверки данных и
Notification Service для отправки уведомления).
4. Контейнеризировать приложение:
o Написать Dockerfile для каждого сервиса.
o Настроить docker-compose.yml для развёртывания всей системы локально.
5. (Опционально) Добавить элементы resilience:
o Обработка ошибок сети (retry, circuit breaker — можно через библиотеки типа
tenacity или resilience4j).
o Логирование и мониторинг (например, через Prometheus и Grafana или просто
консольный лог).
6. Протестировать взаимодействие:
o Проверить работоспособность.
o Продемонстрировать, как система ведёт себя при отключении одного из
сервисов.
Возможные инструменты
Языки: Python, Java, Go, Node.js
Фреймворки: FastAPI, Spring Boot, Express.js
Сетевое взаимодействие: REST, gRPC
Контейнеризация: Docker, docker-compose
Мониторинг (опционально): Prometheus, Grafana, OpenTelemetry
Сценарий использования
Пользователь делает заказ через API.
Order Service проверяет наличие пользователя, обращаясь к User Service по HTTP.
Если пользователь существует — создаётся заказ и отправляется уведомление через
Notification Service (например, в виде email или push).
Все сервисы запускаются в отдельных контейнерах и общаются только через сеть.
Пример реализации сценария
1. 2. 3. 4. 5. 6. Пользователь отправляет POST-запрос на /orders (Order Service).
Order Service получает user_id из тела запроса.
Order Service делает GET-запрос к http://user-service:5000/users/{user_id}.
Если пользователь найден — создаётся заказ.
Order Service отправляет POST-запрос в http://notification-service:5001/notify с
сообщением.
Notification Service логирует уведомление (например, в консоль).
Требования к реализации
Ваше приложение должно включать минимум три микросервиса, например:
1. 2. 3. User Service — управление пользователями (регистрация, получение данных).
Order Service — создание и просмотр заказов.
Notification Service — отправка уведомлений (в лог, email-заглушку и т.п.).
Обязательные условия:
• Все сервисы должны работать в отдельных процессах (лучше — в отдельных
Docker-контейнерах).
• Взаимодействие только через сеть (HTTP/REST или gRPC).
• Каждый сервис имеет собственное хранилище данных (можно использовать SQLite,
встроенную БД или даже in-memory словари на время работы).
• Весь проект должен запускаться одной командой через docker-compose.
Обратите внимание: внутри docker-compose сервисы общаются по именам сервисов, как
указано в docker-compose.yml.
Этапы выполнения
1. Подготовка
Изучите основные принципы сетецентричной архитектуры и микросервисов. Выберите язык
программирования и фреймворк (рекомендовано: Python + FastAPI или Flask).
2. Разработка сервисов
Напишите каждый микросервис как отдельное веб-приложение. Убедитесь, что сервисы
могут запускаться локально и принимать/отправлять HTTP-запросы.
3. Контейнеризация
Создайте Dockerfile для каждого сервиса. Убедитесь, что контейнеры слушают правильные
порты.
4. Сборка и запуск
Напишите docker-compose.yml, где указаны все сервисы, их порты и зависимости. Запустите
систему.
5. Тестирование
Используйте curl или Postman, чтобы протестировать получение пользователя, создание
заказа, проверку, что уведомление отправляется. Отключите один сервис (например,
notification-service) — убедитесь, что остальные продолжают работать (с обработкой
ошибок).
6. Оформление отчёта
Краткий отчёт должен содержать цель и описание архитектуры, диаграмму взаимодействия,
скриншоты работы (запуск, запросы), вывод (какие принципы сетецентричности были
реализованы, с какими трудностями столкнулись).
Важные замечания
• Не допускается передача данных между сервисами через общие файлы, базы данных
или глобальные переменные.
• Все вызовы — только через сеть!
• Обрабатывайте ошибки: что, если user-service недоступен?
• Используйте разные порты для каждого сервиса (например: 5000, 5001, 5002).
Пример структуры проекта
network-centric-app/
├── user-service/
│ ├── app.py
│ ├── Dockerfile │ └── requirements.txt ├── order-service/
│ ├── app.py │ ├── Dockerfile │ └── requirements.txt ├── notification-service/
│ ├── app.py │ ├── Dockerfile │ └── requirements.txt └── docker-compose.yml